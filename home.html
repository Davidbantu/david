<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Kitchen Screen â€” Orders (Realtime)</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600,700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css"/>
  <style>
    :root{
      --main-bg: linear-gradient(to bottom right, #0d47a1, #000000);
      --card-bg: #181c24;
      --accent: #bbdefb;
      --accent2: #263859;
      --primary: #42a5f5;
      --success: #43a047;
      --warning: #ffb300;
      --danger: #e53935;
      --muted: #9aa8c0;
      --glass: rgba(255,255,255,0.03);
      --white: #ffffff;

      --status-off: rgba(255,255,255,0.06);
      --status-ready: #43a047;
      --status-delayed: #e53935;
    }

    * { box-sizing: border-box; }
    html,body { height:100%; margin:0; font-family:"Poppins",sans-serif; color:#fff; background:var(--main-bg); background-attachment:fixed; background-size:cover; }

    .wrap { max-width:1400px; margin:0 auto; padding:18px; min-height:100vh; display:flex; flex-direction:column; gap:12px; }

    .topbar { display:flex; align-items:center; gap:12px; }
    .title { font-weight:700; color:var(--accent); font-size:1.1rem; }
    .controls { margin-left:auto; display:flex; gap:8px; align-items:center; }
    .btn { background:var(--primary); color:#fff; border:0; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:700; }
    .ghost { background:transparent; border:1px solid rgba(255,255,255,0.06); padding:8px 10px; border-radius:8px; color:var(--accent); }

    /* Layout */
    .layout { margin-top:10px; }

    /* grid */
    .grid { display:grid; grid-template-columns:repeat(4,1fr); gap:12px; }
    @media (max-width:1400px){ .grid { grid-template-columns:repeat(3,1fr); } }
    @media (max-width:1000px){ .grid { grid-template-columns:repeat(2,1fr); } }
    @media (max-width:600px){ .grid { grid-template-columns:repeat(1,1fr); } }

    .order-card {
      background:var(--card-bg);
      border-radius:10px;
      padding:14px;
      border:1px solid rgba(255,255,255,0.04);
      box-shadow:0 6px 18px rgba(0,0,0,0.35);
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height:90px;
      word-break:break-word;
      transition:all .12s ease;
      position:relative;
      user-select:none;
    }

    .order-head { display:flex; align-items:center; gap:8px; justify-content:space-between; }
    .order-left { display:flex; flex-direction:column; gap:6px; }
    .order-id { font-size:0.85rem; color:var(--muted); font-weight:700; }
    .order-type-row { display:flex; align-items:center; gap:8px; }
    .order-type {
      display:inline-block;
      padding:6px 10px;
      border-radius:10px;
      background:var(--primary);
      color:#fff;
      font-weight:800;
      font-size:0.9rem;
      border:2px solid rgba(255,255,255,0.03);
      cursor:pointer;
      display:flex;
      align-items:center;
      gap:8px;
    }
    .order-meta { display:flex; gap:8px; align-items:center; color:var(--white); font-size:0.9rem; }

    .timer-slot { display:flex; flex-direction:column; align-items:flex-end; gap:6px; min-width:120px; }
    .timer { font-weight:800; color:var(--white); font-size:0.95rem; }
    .schedule-text { font-size:0.82rem; color:var(--muted); }

    /* Items */
    .items { padding:6px; border-radius:8px; background:rgba(255,255,255,0.01); display:flex; flex-direction:column; gap:8px; }
    .item-row { display:flex; align-items:flex-start; gap:8px; justify-content:space-between; }
    .item-left { display:flex; gap:10px; align-items:flex-start; flex:1 1 auto; min-width:0; }
    .item-name { font-weight:700; color:var(--accent); font-size:0.98rem; white-space:normal; word-wrap:break-word; word-break:break-word; cursor:pointer; }
    .item-note { font-size:0.86rem; color:var(--warning); margin-top:4px; font-style:italic; }
    .item-right { display:flex; gap:8px; align-items:center; flex:0 0 auto; }

    .qty-box { min-width:44px; padding:6px 8px; border-radius:6px; background:var(--order-type, #222); border:1px solid rgba(255,255,255,0.05); color:#fff; font-weight:800; text-align:center; }
    .price { font-size:0.86rem; color:var(--primary); font-weight:700; min-width:60px; text-align:right; }

    .item-done { margin-left:6px; transform:translateY(2px); }
    .item-name.done { text-decoration:line-through; opacity:0.6; color:#9fbcdfff; }

    .order-footer { display:flex; align-items:center; justify-content:space-between; gap:8px; }
    .total { font-weight:800; color:var(--primary); font-size:1rem; }
    .order-actions { display:flex; gap:8px; align-items:center; }

    /* status toggle */
    .status-toggle {
      width:18px;
      height:18px;
      border-radius:50%;
      background:var(--status-off);
      border:2px solid rgba(255,255,255,0.06);
      box-shadow:0 0 6px rgba(0,0,0,0.5);
      cursor:pointer;
    }
    .status-toggle.ready { background:var(--status-ready); box-shadow:0 0 8px rgba(67,160,71,0.35); }
    .status-toggle.delayed { background:var(--status-delayed); box-shadow:0 0 8px rgba(229,57,53,0.35); }

    .arrow { transition:transform .12s ease; font-size:0.95rem; color:var(--accent); margin-left:6px; }

    .collapsed .items { display:none; }
    .collapsed { min-height:60px; }

    .payment-badge { background: rgba(255,255,255,0.03); color: var(--muted); padding:4px 8px; border-radius:8px; font-weight:700; font-size:0.82rem; border:1px solid rgba(255,255,255,0.03); }

    .scheduled-label { background: rgba(255,165,0,0.09); color: var(--warning); padding:4px 8px; border-radius:8px; font-weight:700; font-size:0.82rem; border:1px solid rgba(255,165,0,0.06); }

    .hidden-card { display:none !important; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="title"><i class="fas fa-utensils"></i> Kitchen Screen</div>
      <div class="controls">
        <div id="todayDate" class="small-muted"></div>
        <button id="refreshBtn" class="btn"><i class="fas fa-sync"></i> Refresh</button>
        <div id="counts" style="display:flex;gap:10px;align-items:center;margin-left:12px;">
          <div class="small-muted">Pending:</div><div id="pendingCount" class="small-muted">0</div>
          <div class="small-muted">Completed:</div><div id="completedCount" class="small-muted">0</div>
        </div>
      </div>
    </div>

    <div class="layout">
      <div id="ordersGrid" class="grid" style="margin-top:12px"></div>
      <div id="emptyState" class="small-muted" style="display:none;margin-top:12px">No pending orders for today.</div>
    </div>
  </div>

  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
  <script>
    // Firebase config
    const firebaseConfig = {
      apiKey: "AIzaSyBZCm8Fmp-zNlb2D20gqLCyifky-hGtI",
      authDomain: "newpos-dacb5.firebaseapp.com",
      databaseURL: "https://newpos-dacb5-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "newpos-dacb5",
      storageBucket: "newpos-dacb5.appspot.com",
      messagingSenderId: "667100253940",
      appId: "1:667100253940:web:cfd8f0b9b51b6e697818a1",
      measurementId: "G-F5Q2JCNJ10"
    };
    firebase.initializeApp(firebaseConfig);

    // DOM refs
    const ordersGrid = document.getElementById('ordersGrid');
    const emptyState = document.getElementById('emptyState');
    const pendingCountEl = document.getElementById('pendingCount');
    const completedCountEl = document.getElementById('completedCount');
    const todayDateEl = document.getElementById('todayDate');
    const refreshBtn = document.getElementById('refreshBtn');

    // state
    let ordersCache = {};
    let timers = {};
    let collapsedMap = {};
    let firstSnapshotHandled = false;
    let knownOrderIds = new Set();

    try {
      const saved = localStorage.getItem('kitchen_collapsed_v1');
      if(saved) collapsedMap = JSON.parse(saved) || {};
    } catch(e){ collapsedMap = {}; }

    function todayDateStr(){ return (new Date()).toISOString().slice(0,10); }
    function nowMs(){ return Date.now(); }
    function secondsToHMS(sec){ sec = Math.max(0, Math.floor(sec)); const h = Math.floor(sec/3600); const m = Math.floor((sec%3600)/60); const s = sec%60; return [h,m,s].map(x=>String(x).padStart(2,'0')).join(':'); }
    function minutesToHM(mins){ mins = Math.max(0, Math.floor(mins)); const h = Math.floor(mins/60); const m = mins%60; return [h,m].map(x=>String(x).padStart(2,'0')).join(':'); }
    function statusIsCompleted(s){ if(!s) return false; const ss = String(s).toLowerCase(); return ss === 'completed' || ss === 'paid'; }
    function saveCollapsedMap(){ try { localStorage.setItem('kitchen_collapsed_v1', JSON.stringify(collapsedMap)); } catch(e){} }

    function playAlertSound(){
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = 'sine';
        o.frequency.value = 880;
        g.gain.value = 0.0001;
        o.connect(g);
        g.connect(ctx.destination);
        const now = ctx.currentTime;
        g.gain.linearRampToValueAtTime(0.15, now + 0.01);
        o.start(now);
        g.gain.linearRampToValueAtTime(0.0001, now + 0.35);
        o.stop(now + 0.36);
      } catch(e){}
    }

    // Build a single order card
    function buildOrderCard(order){
      const card = document.createElement('div');
      card.className = 'order-card';
      card.dataset.id = order.id;

      const head = document.createElement('div');
      head.className = 'order-head';

      const left = document.createElement('div');
      left.className = 'order-left';
      const idEl = document.createElement('div'); idEl.className = 'order-id'; idEl.textContent = 'Order #' + (order.id || '');

      const typeRow = document.createElement('div');
      typeRow.className = 'order-type-row';
      const typeEl = document.createElement('div');
      typeEl.className = 'order-type';
      typeEl.textContent = order.table || '';

      const arrow = document.createElement('span');
      arrow.className = 'arrow';
      arrow.innerHTML = collapsedMap[String(order.id)] ? '&#9654;' : '&#9660;'; // â–¶ or â–¼
      typeEl.appendChild(arrow);

      // Clicking order type toggles the item list collapse
      typeEl.addEventListener('click', (ev) => {
        ev.stopPropagation();
        const id = String(order.id);
        const isCollapsed = !!collapsedMap[id];
        if(isCollapsed){
          delete collapsedMap[id];
          arrow.innerHTML = '&#9660;';
          card.classList.remove('collapsed');
        } else {
          collapsedMap[id] = true;
          arrow.innerHTML = '&#9654;';
          card.classList.add('collapsed');
        }
        saveCollapsedMap();
      });

      typeRow.appendChild(typeEl);
      left.appendChild(typeRow);
      left.appendChild(idEl);

      const meta = document.createElement('div'); meta.className = 'order-meta';
      const dateEl = document.createElement('div'); dateEl.textContent = (order.date || '') + ' ' + (order.time || '');
      meta.appendChild(dateEl);

      const paymentBadge = document.createElement('div');
      paymentBadge.className = 'payment-badge';
      const statusLower = (order.status || '').toString().toLowerCase();
      paymentBadge.textContent = (statusLower === 'paid') ? 'Paid' : 'Payment Pending';
      meta.appendChild(paymentBadge);
      left.appendChild(meta);

      // right: timer and status toggle
      const right = document.createElement('div'); right.className = 'timer-slot';
      const statusRow = document.createElement('div'); statusRow.style.display = 'flex'; statusRow.style.alignItems = 'center'; statusRow.style.gap = '8px';

      const statusToggle = document.createElement('div'); statusToggle.className = 'status-toggle';
      const initialReady = (order.readyState || 'off');
      if(initialReady === 'ready') statusToggle.classList.add('ready');
      if(initialReady === 'delayed') statusToggle.classList.add('delayed');

      statusToggle.addEventListener('click', (ev)=> {
        ev.stopPropagation();
        const cur = (order.readyState || 'off');
        const next = cur === 'off' ? 'ready' : (cur === 'ready' ? 'delayed' : 'off');
        setReadyState(order.id, next);
      });

      const timerEl = document.createElement('div'); timerEl.className = 'timer'; timerEl.textContent = '00:00:00';
      statusRow.appendChild(statusToggle); statusRow.appendChild(timerEl);
      right.appendChild(statusRow);

      // only show scheduled label when the order has scheduledTime
      if(order.scheduledTime && String(order.scheduledTime).trim()){
        const scheduleText = document.createElement('div');
        scheduleText.className = 'schedule-text';
        scheduleText.textContent = 'Scheduled â€¢ ' + order.scheduledTime;
        right.appendChild(scheduleText);
      }

      head.appendChild(left); head.appendChild(right);
      card.appendChild(head);

      // order note
      if(order.note && String(order.note).trim()){
        const orderNote = document.createElement('div');
        orderNote.className = 'item-note';
        orderNote.style.marginTop = '6px';
        orderNote.style.marginBottom = '6px';
        orderNote.textContent = order.note;
        card.appendChild(orderNote);
      }

      // items list
      const itemsWrap = document.createElement('div'); itemsWrap.className = 'items';
      const items = Array.isArray(order.items) ? order.items : [];
      if(items.length === 0){
        const none = document.createElement('div'); none.className = 'small-muted'; none.textContent = 'No items';
        itemsWrap.appendChild(none);
      } else {
        items.forEach((it, idx) => {
          const row = document.createElement('div'); row.className = 'item-row';
          const leftBlock = document.createElement('div'); leftBlock.className = 'item-left';

          // checkbox
          const cb = document.createElement('input'); cb.type = 'checkbox'; cb.className = 'item-done'; cb.checked = !!it.done;
          cb.title = 'Mark item done';
          cb.addEventListener('click', (ev)=> { ev.stopPropagation(); toggleItemDone(order.id, idx, cb.checked); });
          leftBlock.appendChild(cb);

          const nameAndNote = document.createElement('div'); nameAndNote.style.minWidth = '0';
          const name = document.createElement('div'); name.className = 'item-name' + (it.done ? ' done' : ''); name.textContent = it.name || '';
          name.addEventListener('click', (ev)=> { ev.stopPropagation(); const newVal = !Boolean(it.done); toggleItemDone(order.id, idx, newVal); });
          nameAndNote.appendChild(name);
          if(it.note && String(it.note).trim()){
            const inote = document.createElement('div'); inote.className = 'item-note'; inote.textContent = it.note; nameAndNote.appendChild(inote);
          }
          leftBlock.appendChild(nameAndNote);

          const rightBlock = document.createElement('div'); rightBlock.className = 'item-right';
          const qtyBox = document.createElement('div'); qtyBox.className = 'qty-box'; qtyBox.textContent = 'x' + (it.qty || 1);
          const price = document.createElement('div'); price.className = 'price'; price.textContent = 'â‚¬' + (((it.price || 0) * (it.qty || 1)).toFixed(2));
          rightBlock.appendChild(qtyBox); rightBlock.appendChild(price);

          row.appendChild(leftBlock); row.appendChild(rightBlock);
          itemsWrap.appendChild(row);
        });
      }
      card.appendChild(itemsWrap);

      // footer with styled buttons
      const footer = document.createElement('div'); footer.className = 'order-footer';
      const totalEl = document.createElement('div'); totalEl.className = 'total'; totalEl.textContent = 'Total: â‚¬' + Number(order.total || 0).toFixed(2);
      footer.appendChild(totalEl);

      const actions = document.createElement('div'); actions.className = 'order-actions';

      // Mark all items (popup confirm)
      if(!statusIsCompleted(order.status)){
        const markAllBtn = document.createElement('button'); markAllBtn.className = 'btn'; markAllBtn.textContent = 'Mark all items';
        markAllBtn.addEventListener('click', (ev)=>{
          ev.stopPropagation();
          if(window.confirm('Mark all items in order #' + order.id + ' as done?')) {
            markAllItems(order.id);
          }
        });
        actions.appendChild(markAllBtn);

        // Done button should show confirmation popup and upon OK hide the order (set completed)
        const doneBtn = document.createElement('button'); doneBtn.className = 'btn'; doneBtn.textContent = 'Done';
        doneBtn.addEventListener('click', (ev)=>{
          ev.stopPropagation();
          if(window.confirm('Mark order #' + order.id + ' as DONE (completed)?')) {
            markOrderDone(order.id);
            // hide will occur because render excludes completed orders
          }
        });
        actions.appendChild(doneBtn);
      } else {
        const doneLbl = document.createElement('div'); doneLbl.className = 'small-muted'; doneLbl.textContent = 'Completed';
        actions.appendChild(doneLbl);
      }

      // Open (button)
      const openBtn = document.createElement('button'); openBtn.className = 'btn'; openBtn.textContent = 'Open';
      openBtn.addEventListener('click', (ev)=> { ev.stopPropagation(); openOrderInOrderPage(order.id); });
      actions.appendChild(openBtn);

      footer.appendChild(actions);
      card.appendChild(footer);

      // apply collapse stored state
      if(collapsedMap[String(order.id)]) card.classList.add('collapsed');

      // start timer
      startCardTimer(order.id, order, timerEl);

      // hold-to-open popup: open a quick alert listing items (quick view)
      let holdTimer = null;
      const HOLD_DELAY = 600;
      function pointerDown(){ holdTimer = setTimeout(()=>{ openOrderPopupView(order.id); holdTimer = null; }, HOLD_DELAY); }
      function cancelHold(){ if(holdTimer){ clearTimeout(holdTimer); holdTimer = null; } }

      card.addEventListener('mousedown', pointerDown);
      card.addEventListener('touchstart', pointerDown, {passive:true});
      card.addEventListener('mouseup', (ev)=> { cancelHold(); });
      card.addEventListener('mouseleave', cancelHold);
      card.addEventListener('touchend', cancelHold);

      return card;
    }

    // timer logic (scheduled or elapsed). When scheduled shows minutes left and red if <30m.
    function startCardTimer(id, order, displayEl){
      if(timers[id] && timers[id].interval) clearInterval(timers[id].interval);

      function update(){
        const now = nowMs();
        const scheduledTime = order.scheduledTime || order.scheduled || null;
        let scheduledMs = null;
        let showScheduledCountdown = false;
        if(scheduledTime){
          try {
            const datePart = order.scheduledDate || order.date || todayDateStr();
            const timePart = scheduledTime.length <= 5 ? scheduledTime + ':00' : scheduledTime;
            const dt = new Date(datePart + 'T' + timePart);
            if(!isNaN(dt.getTime())){
              scheduledMs = dt.getTime();
              if(scheduledMs > now) showScheduledCountdown = true;
            }
          } catch(e){ showScheduledCountdown = false; scheduledMs = null; }
        }

        if(showScheduledCountdown && scheduledMs){
          const remainingSec = Math.floor((scheduledMs - now) / 1000);
          const lessThan30Min = remainingSec <= (30 * 60);
          const minsLeft = Math.ceil(remainingSec / 60);
          displayEl.textContent = minutesToHM(minsLeft) + ' left';
          displayEl.style.color = lessThan30Min ? 'var(--danger)' : 'var(--white)';
        } else {
          const created = order.createdAt || (order.date ? new Date(order.date + 'T' + (order.time || '00:00:00')).getTime() : now);
          if(statusIsCompleted(order.status)){
            const completedAt = order.completedAt || order.updatedAt || now;
            displayEl.textContent = secondsToHMS(Math.floor((completedAt - created)/1000)) + ' (done)';
            displayEl.style.color = 'var(--muted)';
          } else {
            displayEl.textContent = secondsToHMS(Math.floor((now - created)/1000));
            displayEl.style.color = 'var(--white)';
          }
        }
      }

      update();
      const iv = setInterval(update, 1000);
      timers[id] = { interval: iv };
    }

    function stopCardTimer(id){
      if(timers[id] && timers[id].interval){ clearInterval(timers[id].interval); delete timers[id]; }
    }

    // mark single item done (firebase)
    function toggleItemDone(orderId, itemIdx, doneValue){
      const updates = {};
      updates[`orders/${orderId}/items/${itemIdx}/done`] = !!doneValue;
      updates[`orders/${orderId}/updatedAt`] = nowMs();
      firebase.database().ref().update(updates).catch(err=>console.error('Error toggling item done',err));
    }

    function setReadyState(orderId, state){
      firebase.database().ref(`orders/${orderId}`).update({ readyState: state, updatedAt: nowMs() }).catch(err=>console.error('Error setting ready state', err));
    }

    // mark all items
    function markAllItems(orderId){
      const ref = firebase.database().ref(`orders/${orderId}`);
      ref.once('value').then(snap => {
        const data = snap.val();
        if(!data) throw new Error('Order not found');
        const items = Array.isArray(data.items) ? data.items.slice() : [];
        for(let i=0;i<items.length;i++){ items[i].done = true; items[i].doneAt = nowMs(); }
        return ref.update({ items: items, updatedAt: nowMs() });
      }).catch(err => { console.error('Error markAllItems', err); alert('Error marking all items: ' + (err && err.message)); });
    }

    // mark order done: set status completed and hide from page (render excludes completed)
    function markOrderDone(orderId){
      const ref = firebase.database().ref(`orders/${orderId}`);
      const now = nowMs();
      ref.update({ status: 'completed', completedAt: now, updatedAt: now }).then(()=> {
        stopCardTimer(orderId);
        // render will exclude completed orders
      }).catch(err=>console.error('Error marking order done', err));
    }

    function openOrderInOrderPage(orderId){ window.location.href = 'order.html?order=' + encodeURIComponent(orderId); }

    // quick popup view for hold-to-open: simple alert showing details (keeps UI minimal)
    function openOrderPopupView(orderId){
      const order = ordersCache[orderId];
      if(!order) return;
      const items = Array.isArray(order.items) ? order.items : [];
      const lines = items.map(it => `${it.qty || 1} x ${it.name}${it.note ? ' â€” ' + it.note : ''}`);
      alert(`Order #${order.id}\nTable: ${order.table || ''}\n\nItems:\n` + (lines.length ? lines.join('\n') : 'No items'));
    }

    // Render today's orders but exclude completed ones so Done hides them
    function renderOrdersGrid(){
      const today = todayDateStr();
      const all = Object.values(ordersCache || {});
      const todays = all.filter(o => (o.date || '') === today);
      // exclude completed orders so they are hidden from this page after Done
      const visible = todays.filter(o => !statusIsCompleted(o.status));
      ordersGrid.innerHTML = '';
      if(visible.length === 0){ emptyState.style.display = 'block'; } else { emptyState.style.display = 'none'; }
      visible.sort((a,b) => (b.createdAt || 0) - (a.createdAt || 0));
      visible.forEach(o => { const card = buildOrderCard(o); ordersGrid.appendChild(card); });
      const pendingCount = todays.filter(o => !statusIsCompleted(o.status)).length;
      const completedCount = todays.filter(o => statusIsCompleted(o.status)).length;
      pendingCountEl.textContent = pendingCount;
      completedCountEl.textContent = completedCount;
      todayDateEl.textContent = today;
    }

    // Realtime listener with first-snapshot sound suppression
    function attachOrdersListener(){
      const ref = firebase.database().ref('orders');
      ref.on('value', snap => {
        const val = snap.val() || {};
        const incomingKeys = Object.keys(val || {});
        if(!firstSnapshotHandled){
          knownOrderIds = new Set(incomingKeys);
          ordersCache = {};
          incomingKeys.forEach(k => ordersCache[k] = val[k]);
          Object.keys(ordersCache).forEach(k => {
            const o = ordersCache[k];
            if(!o.createdAt){
              try { if(o.date && o.time){ const dt = new Date(o.date + 'T' + (o.time || '00:00:00')); o.createdAt = dt.getTime(); } else o.createdAt = nowMs(); } catch(e){ o.createdAt = nowMs(); }
            }
          });
          renderOrdersGrid();
          firstSnapshotHandled = true;
          return;
        }

        const newIds = [];
        for(const k of incomingKeys){ if(!knownOrderIds.has(k)) newIds.push(k); }
        knownOrderIds = new Set(incomingKeys);

        ordersCache = {};
        incomingKeys.forEach(k => ordersCache[k] = val[k]);
        Object.keys(ordersCache).forEach(k => {
          const o = ordersCache[k];
          if(!o.createdAt){
            try { if(o.date && o.time){ const dt = new Date(o.date + 'T' + (o.time || '00:00:00')); o.createdAt = dt.getTime(); } else o.createdAt = nowMs(); } catch(e){ o.createdAt = nowMs(); }
          }
        });

        if(newIds.length > 0) playAlertSound();

        const existingIds = Object.keys(ordersCache);
        Object.keys(timers).forEach(id => { if(!existingIds.includes(id)) stopCardTimer(id); });

        renderOrdersGrid();
      }, err => { console.error('Firebase read error', err); });
    }

    refreshBtn.addEventListener('click', ()=> {
      firebase.database().ref('orders').once('value').then(snap => {
        const val = snap.val() || {};
        ordersCache = {}; Object.keys(val).forEach(k => ordersCache[k] = val[k]);
        renderOrdersGrid();
      }).catch(err => console.error(err));
    });

    // init
    attachOrdersListener();

    window.addEventListener('beforeunload', () => {
      Object.keys(timers).forEach(k => { if(timers[k] && timers[k].interval) clearInterval(timers[k].interval); });
    });
  </script>
</body>
</html>
